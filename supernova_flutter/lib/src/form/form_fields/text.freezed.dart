// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'text.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SupernovaTextFormField {
  TextEditingController get controller => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)
        singleLine,
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)
        multiLine,
    required TResult Function(
            TextEditingController controller, TextInputAction textInputAction)
        emailAddress,
    required TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)
        password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult? Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult? Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleLineSupernovaTextFormField value)
        singleLine,
    required TResult Function(_MultiLineSupernovaTextFormField value) multiLine,
    required TResult Function(_EmailAddressSupernovaTextFormField value)
        emailAddress,
    required TResult Function(_PasswordSupernovaTextFormField value) password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult? Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult? Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult? Function(_PasswordSupernovaTextFormField value)? password,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult Function(_PasswordSupernovaTextFormField value)? password,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SupernovaTextFormFieldCopyWith<SupernovaTextFormField> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SupernovaTextFormFieldCopyWith<$Res> {
  factory $SupernovaTextFormFieldCopyWith(SupernovaTextFormField value,
          $Res Function(SupernovaTextFormField) then) =
      _$SupernovaTextFormFieldCopyWithImpl<$Res, SupernovaTextFormField>;
  @useResult
  $Res call({TextEditingController controller});
}

/// @nodoc
class _$SupernovaTextFormFieldCopyWithImpl<$Res,
        $Val extends SupernovaTextFormField>
    implements $SupernovaTextFormFieldCopyWith<$Res> {
  _$SupernovaTextFormFieldCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? controller = null,
  }) {
    return _then(_value.copyWith(
      controller: null == controller
          ? _value.controller
          : controller // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SingleLineSupernovaTextFormFieldCopyWith<$Res>
    implements $SupernovaTextFormFieldCopyWith<$Res> {
  factory _$$_SingleLineSupernovaTextFormFieldCopyWith(
          _$_SingleLineSupernovaTextFormField value,
          $Res Function(_$_SingleLineSupernovaTextFormField) then) =
      __$$_SingleLineSupernovaTextFormFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TextEditingController controller,
      List<String>? autofillHints,
      TextInputType? keyboardType,
      List<TextInputFormatter>? inputFormatters,
      int? maxLength,
      TextCapitalization textCapitalization,
      SupernovaFormFieldValidator<String>? validator,
      TextInputAction textInputAction,
      String? hintText,
      FlatIcon? prefixIcon,
      Widget? suffixIcon});
}

/// @nodoc
class __$$_SingleLineSupernovaTextFormFieldCopyWithImpl<$Res>
    extends _$SupernovaTextFormFieldCopyWithImpl<$Res,
        _$_SingleLineSupernovaTextFormField>
    implements _$$_SingleLineSupernovaTextFormFieldCopyWith<$Res> {
  __$$_SingleLineSupernovaTextFormFieldCopyWithImpl(
      _$_SingleLineSupernovaTextFormField _value,
      $Res Function(_$_SingleLineSupernovaTextFormField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? controller = null,
    Object? autofillHints = freezed,
    Object? keyboardType = freezed,
    Object? inputFormatters = freezed,
    Object? maxLength = freezed,
    Object? textCapitalization = null,
    Object? validator = freezed,
    Object? textInputAction = null,
    Object? hintText = freezed,
    Object? prefixIcon = freezed,
    Object? suffixIcon = freezed,
  }) {
    return _then(_$_SingleLineSupernovaTextFormField(
      null == controller
          ? _value.controller
          : controller // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      autofillHints: freezed == autofillHints
          ? _value._autofillHints
          : autofillHints // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      keyboardType: freezed == keyboardType
          ? _value.keyboardType
          : keyboardType // ignore: cast_nullable_to_non_nullable
              as TextInputType?,
      inputFormatters: freezed == inputFormatters
          ? _value._inputFormatters
          : inputFormatters // ignore: cast_nullable_to_non_nullable
              as List<TextInputFormatter>?,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      textCapitalization: null == textCapitalization
          ? _value.textCapitalization
          : textCapitalization // ignore: cast_nullable_to_non_nullable
              as TextCapitalization,
      validator: freezed == validator
          ? _value.validator
          : validator // ignore: cast_nullable_to_non_nullable
              as SupernovaFormFieldValidator<String>?,
      textInputAction: null == textInputAction
          ? _value.textInputAction
          : textInputAction // ignore: cast_nullable_to_non_nullable
              as TextInputAction,
      hintText: freezed == hintText
          ? _value.hintText
          : hintText // ignore: cast_nullable_to_non_nullable
              as String?,
      prefixIcon: freezed == prefixIcon
          ? _value.prefixIcon
          : prefixIcon // ignore: cast_nullable_to_non_nullable
              as FlatIcon?,
      suffixIcon: freezed == suffixIcon
          ? _value.suffixIcon
          : suffixIcon // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc

class _$_SingleLineSupernovaTextFormField
    extends _SingleLineSupernovaTextFormField {
  const _$_SingleLineSupernovaTextFormField(this.controller,
      {required final List<String>? autofillHints,
      this.keyboardType,
      final List<TextInputFormatter>? inputFormatters,
      this.maxLength,
      this.textCapitalization = TextCapitalization.sentences,
      this.validator,
      required this.textInputAction,
      this.hintText,
      this.prefixIcon,
      this.suffixIcon})
      : _autofillHints = autofillHints,
        _inputFormatters = inputFormatters,
        super._();

  @override
  final TextEditingController controller;
  final List<String>? _autofillHints;
  @override
  List<String>? get autofillHints {
    final value = _autofillHints;
    if (value == null) return null;
    if (_autofillHints is EqualUnmodifiableListView) return _autofillHints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final TextInputType? keyboardType;
  final List<TextInputFormatter>? _inputFormatters;
  @override
  List<TextInputFormatter>? get inputFormatters {
    final value = _inputFormatters;
    if (value == null) return null;
    if (_inputFormatters is EqualUnmodifiableListView) return _inputFormatters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? maxLength;
  @override
  @JsonKey()
  final TextCapitalization textCapitalization;
  @override
  final SupernovaFormFieldValidator<String>? validator;
  @override
  final TextInputAction textInputAction;
  @override
  final String? hintText;
  @override
  final FlatIcon? prefixIcon;
  @override
  final Widget? suffixIcon;

  @override
  String toString() {
    return 'SupernovaTextFormField.singleLine(controller: $controller, autofillHints: $autofillHints, keyboardType: $keyboardType, inputFormatters: $inputFormatters, maxLength: $maxLength, textCapitalization: $textCapitalization, validator: $validator, textInputAction: $textInputAction, hintText: $hintText, prefixIcon: $prefixIcon, suffixIcon: $suffixIcon)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SingleLineSupernovaTextFormField &&
            (identical(other.controller, controller) ||
                other.controller == controller) &&
            const DeepCollectionEquality()
                .equals(other._autofillHints, _autofillHints) &&
            (identical(other.keyboardType, keyboardType) ||
                other.keyboardType == keyboardType) &&
            const DeepCollectionEquality()
                .equals(other._inputFormatters, _inputFormatters) &&
            (identical(other.maxLength, maxLength) ||
                other.maxLength == maxLength) &&
            (identical(other.textCapitalization, textCapitalization) ||
                other.textCapitalization == textCapitalization) &&
            (identical(other.validator, validator) ||
                other.validator == validator) &&
            (identical(other.textInputAction, textInputAction) ||
                other.textInputAction == textInputAction) &&
            (identical(other.hintText, hintText) ||
                other.hintText == hintText) &&
            (identical(other.prefixIcon, prefixIcon) ||
                other.prefixIcon == prefixIcon) &&
            (identical(other.suffixIcon, suffixIcon) ||
                other.suffixIcon == suffixIcon));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      controller,
      const DeepCollectionEquality().hash(_autofillHints),
      keyboardType,
      const DeepCollectionEquality().hash(_inputFormatters),
      maxLength,
      textCapitalization,
      validator,
      textInputAction,
      hintText,
      prefixIcon,
      suffixIcon);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SingleLineSupernovaTextFormFieldCopyWith<
          _$_SingleLineSupernovaTextFormField>
      get copyWith => __$$_SingleLineSupernovaTextFormFieldCopyWithImpl<
          _$_SingleLineSupernovaTextFormField>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)
        singleLine,
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)
        multiLine,
    required TResult Function(
            TextEditingController controller, TextInputAction textInputAction)
        emailAddress,
    required TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)
        password,
  }) {
    return singleLine(
        controller,
        autofillHints,
        keyboardType,
        inputFormatters,
        maxLength,
        textCapitalization,
        validator,
        textInputAction,
        hintText,
        prefixIcon,
        suffixIcon);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult? Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult? Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
  }) {
    return singleLine?.call(
        controller,
        autofillHints,
        keyboardType,
        inputFormatters,
        maxLength,
        textCapitalization,
        validator,
        textInputAction,
        hintText,
        prefixIcon,
        suffixIcon);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
    required TResult orElse(),
  }) {
    if (singleLine != null) {
      return singleLine(
          controller,
          autofillHints,
          keyboardType,
          inputFormatters,
          maxLength,
          textCapitalization,
          validator,
          textInputAction,
          hintText,
          prefixIcon,
          suffixIcon);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleLineSupernovaTextFormField value)
        singleLine,
    required TResult Function(_MultiLineSupernovaTextFormField value) multiLine,
    required TResult Function(_EmailAddressSupernovaTextFormField value)
        emailAddress,
    required TResult Function(_PasswordSupernovaTextFormField value) password,
  }) {
    return singleLine(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult? Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult? Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult? Function(_PasswordSupernovaTextFormField value)? password,
  }) {
    return singleLine?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult Function(_PasswordSupernovaTextFormField value)? password,
    required TResult orElse(),
  }) {
    if (singleLine != null) {
      return singleLine(this);
    }
    return orElse();
  }
}

abstract class _SingleLineSupernovaTextFormField
    extends SupernovaTextFormField {
  const factory _SingleLineSupernovaTextFormField(
      final TextEditingController controller,
      {required final List<String>? autofillHints,
      final TextInputType? keyboardType,
      final List<TextInputFormatter>? inputFormatters,
      final int? maxLength,
      final TextCapitalization textCapitalization,
      final SupernovaFormFieldValidator<String>? validator,
      required final TextInputAction textInputAction,
      final String? hintText,
      final FlatIcon? prefixIcon,
      final Widget? suffixIcon}) = _$_SingleLineSupernovaTextFormField;
  const _SingleLineSupernovaTextFormField._() : super._();

  @override
  TextEditingController get controller;
  List<String>? get autofillHints;
  TextInputType? get keyboardType;
  List<TextInputFormatter>? get inputFormatters;
  int? get maxLength;
  TextCapitalization get textCapitalization;
  SupernovaFormFieldValidator<String>? get validator;
  TextInputAction get textInputAction;
  String? get hintText;
  FlatIcon? get prefixIcon;
  Widget? get suffixIcon;
  @override
  @JsonKey(ignore: true)
  _$$_SingleLineSupernovaTextFormFieldCopyWith<
          _$_SingleLineSupernovaTextFormField>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_MultiLineSupernovaTextFormFieldCopyWith<$Res>
    implements $SupernovaTextFormFieldCopyWith<$Res> {
  factory _$$_MultiLineSupernovaTextFormFieldCopyWith(
          _$_MultiLineSupernovaTextFormField value,
          $Res Function(_$_MultiLineSupernovaTextFormField) then) =
      __$$_MultiLineSupernovaTextFormFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TextEditingController controller,
      List<String>? autofillHints,
      TextInputType? keyboardType,
      int? maxLength,
      SupernovaFormFieldValidator<String>? validator,
      String? hintText});
}

/// @nodoc
class __$$_MultiLineSupernovaTextFormFieldCopyWithImpl<$Res>
    extends _$SupernovaTextFormFieldCopyWithImpl<$Res,
        _$_MultiLineSupernovaTextFormField>
    implements _$$_MultiLineSupernovaTextFormFieldCopyWith<$Res> {
  __$$_MultiLineSupernovaTextFormFieldCopyWithImpl(
      _$_MultiLineSupernovaTextFormField _value,
      $Res Function(_$_MultiLineSupernovaTextFormField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? controller = null,
    Object? autofillHints = freezed,
    Object? keyboardType = freezed,
    Object? maxLength = freezed,
    Object? validator = freezed,
    Object? hintText = freezed,
  }) {
    return _then(_$_MultiLineSupernovaTextFormField(
      null == controller
          ? _value.controller
          : controller // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      autofillHints: freezed == autofillHints
          ? _value._autofillHints
          : autofillHints // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      keyboardType: freezed == keyboardType
          ? _value.keyboardType
          : keyboardType // ignore: cast_nullable_to_non_nullable
              as TextInputType?,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      validator: freezed == validator
          ? _value.validator
          : validator // ignore: cast_nullable_to_non_nullable
              as SupernovaFormFieldValidator<String>?,
      hintText: freezed == hintText
          ? _value.hintText
          : hintText // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_MultiLineSupernovaTextFormField
    extends _MultiLineSupernovaTextFormField {
  const _$_MultiLineSupernovaTextFormField(this.controller,
      {required final List<String>? autofillHints,
      this.keyboardType,
      this.maxLength,
      this.validator,
      this.hintText})
      : _autofillHints = autofillHints,
        super._();

  @override
  final TextEditingController controller;
  final List<String>? _autofillHints;
  @override
  List<String>? get autofillHints {
    final value = _autofillHints;
    if (value == null) return null;
    if (_autofillHints is EqualUnmodifiableListView) return _autofillHints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final TextInputType? keyboardType;
  @override
  final int? maxLength;
  @override
  final SupernovaFormFieldValidator<String>? validator;
  @override
  final String? hintText;

  @override
  String toString() {
    return 'SupernovaTextFormField.multiLine(controller: $controller, autofillHints: $autofillHints, keyboardType: $keyboardType, maxLength: $maxLength, validator: $validator, hintText: $hintText)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MultiLineSupernovaTextFormField &&
            (identical(other.controller, controller) ||
                other.controller == controller) &&
            const DeepCollectionEquality()
                .equals(other._autofillHints, _autofillHints) &&
            (identical(other.keyboardType, keyboardType) ||
                other.keyboardType == keyboardType) &&
            (identical(other.maxLength, maxLength) ||
                other.maxLength == maxLength) &&
            (identical(other.validator, validator) ||
                other.validator == validator) &&
            (identical(other.hintText, hintText) ||
                other.hintText == hintText));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      controller,
      const DeepCollectionEquality().hash(_autofillHints),
      keyboardType,
      maxLength,
      validator,
      hintText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MultiLineSupernovaTextFormFieldCopyWith<
          _$_MultiLineSupernovaTextFormField>
      get copyWith => __$$_MultiLineSupernovaTextFormFieldCopyWithImpl<
          _$_MultiLineSupernovaTextFormField>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)
        singleLine,
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)
        multiLine,
    required TResult Function(
            TextEditingController controller, TextInputAction textInputAction)
        emailAddress,
    required TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)
        password,
  }) {
    return multiLine(controller, autofillHints, keyboardType, maxLength,
        validator, hintText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult? Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult? Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
  }) {
    return multiLine?.call(controller, autofillHints, keyboardType, maxLength,
        validator, hintText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
    required TResult orElse(),
  }) {
    if (multiLine != null) {
      return multiLine(controller, autofillHints, keyboardType, maxLength,
          validator, hintText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleLineSupernovaTextFormField value)
        singleLine,
    required TResult Function(_MultiLineSupernovaTextFormField value) multiLine,
    required TResult Function(_EmailAddressSupernovaTextFormField value)
        emailAddress,
    required TResult Function(_PasswordSupernovaTextFormField value) password,
  }) {
    return multiLine(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult? Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult? Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult? Function(_PasswordSupernovaTextFormField value)? password,
  }) {
    return multiLine?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult Function(_PasswordSupernovaTextFormField value)? password,
    required TResult orElse(),
  }) {
    if (multiLine != null) {
      return multiLine(this);
    }
    return orElse();
  }
}

abstract class _MultiLineSupernovaTextFormField extends SupernovaTextFormField {
  const factory _MultiLineSupernovaTextFormField(
      final TextEditingController controller,
      {required final List<String>? autofillHints,
      final TextInputType? keyboardType,
      final int? maxLength,
      final SupernovaFormFieldValidator<String>? validator,
      final String? hintText}) = _$_MultiLineSupernovaTextFormField;
  const _MultiLineSupernovaTextFormField._() : super._();

  @override
  TextEditingController get controller;
  List<String>? get autofillHints;
  TextInputType? get keyboardType;
  int? get maxLength;
  SupernovaFormFieldValidator<String>? get validator;
  String? get hintText;
  @override
  @JsonKey(ignore: true)
  _$$_MultiLineSupernovaTextFormFieldCopyWith<
          _$_MultiLineSupernovaTextFormField>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EmailAddressSupernovaTextFormFieldCopyWith<$Res>
    implements $SupernovaTextFormFieldCopyWith<$Res> {
  factory _$$_EmailAddressSupernovaTextFormFieldCopyWith(
          _$_EmailAddressSupernovaTextFormField value,
          $Res Function(_$_EmailAddressSupernovaTextFormField) then) =
      __$$_EmailAddressSupernovaTextFormFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TextEditingController controller, TextInputAction textInputAction});
}

/// @nodoc
class __$$_EmailAddressSupernovaTextFormFieldCopyWithImpl<$Res>
    extends _$SupernovaTextFormFieldCopyWithImpl<$Res,
        _$_EmailAddressSupernovaTextFormField>
    implements _$$_EmailAddressSupernovaTextFormFieldCopyWith<$Res> {
  __$$_EmailAddressSupernovaTextFormFieldCopyWithImpl(
      _$_EmailAddressSupernovaTextFormField _value,
      $Res Function(_$_EmailAddressSupernovaTextFormField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? controller = null,
    Object? textInputAction = null,
  }) {
    return _then(_$_EmailAddressSupernovaTextFormField(
      null == controller
          ? _value.controller
          : controller // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      textInputAction: null == textInputAction
          ? _value.textInputAction
          : textInputAction // ignore: cast_nullable_to_non_nullable
              as TextInputAction,
    ));
  }
}

/// @nodoc

class _$_EmailAddressSupernovaTextFormField
    extends _EmailAddressSupernovaTextFormField {
  const _$_EmailAddressSupernovaTextFormField(this.controller,
      {required this.textInputAction})
      : super._();

  @override
  final TextEditingController controller;
  @override
  final TextInputAction textInputAction;

  @override
  String toString() {
    return 'SupernovaTextFormField.emailAddress(controller: $controller, textInputAction: $textInputAction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EmailAddressSupernovaTextFormField &&
            (identical(other.controller, controller) ||
                other.controller == controller) &&
            (identical(other.textInputAction, textInputAction) ||
                other.textInputAction == textInputAction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, controller, textInputAction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EmailAddressSupernovaTextFormFieldCopyWith<
          _$_EmailAddressSupernovaTextFormField>
      get copyWith => __$$_EmailAddressSupernovaTextFormFieldCopyWithImpl<
          _$_EmailAddressSupernovaTextFormField>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)
        singleLine,
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)
        multiLine,
    required TResult Function(
            TextEditingController controller, TextInputAction textInputAction)
        emailAddress,
    required TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)
        password,
  }) {
    return emailAddress(controller, textInputAction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult? Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult? Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
  }) {
    return emailAddress?.call(controller, textInputAction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
    required TResult orElse(),
  }) {
    if (emailAddress != null) {
      return emailAddress(controller, textInputAction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleLineSupernovaTextFormField value)
        singleLine,
    required TResult Function(_MultiLineSupernovaTextFormField value) multiLine,
    required TResult Function(_EmailAddressSupernovaTextFormField value)
        emailAddress,
    required TResult Function(_PasswordSupernovaTextFormField value) password,
  }) {
    return emailAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult? Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult? Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult? Function(_PasswordSupernovaTextFormField value)? password,
  }) {
    return emailAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult Function(_PasswordSupernovaTextFormField value)? password,
    required TResult orElse(),
  }) {
    if (emailAddress != null) {
      return emailAddress(this);
    }
    return orElse();
  }
}

abstract class _EmailAddressSupernovaTextFormField
    extends SupernovaTextFormField {
  const factory _EmailAddressSupernovaTextFormField(
          final TextEditingController controller,
          {required final TextInputAction textInputAction}) =
      _$_EmailAddressSupernovaTextFormField;
  const _EmailAddressSupernovaTextFormField._() : super._();

  @override
  TextEditingController get controller;
  TextInputAction get textInputAction;
  @override
  @JsonKey(ignore: true)
  _$$_EmailAddressSupernovaTextFormFieldCopyWith<
          _$_EmailAddressSupernovaTextFormField>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PasswordSupernovaTextFormFieldCopyWith<$Res>
    implements $SupernovaTextFormFieldCopyWith<$Res> {
  factory _$$_PasswordSupernovaTextFormFieldCopyWith(
          _$_PasswordSupernovaTextFormField value,
          $Res Function(_$_PasswordSupernovaTextFormField) then) =
      __$$_PasswordSupernovaTextFormFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TextEditingController controller,
      SupernovaPasswordFormFieldRole role,
      TextInputAction textInputAction});
}

/// @nodoc
class __$$_PasswordSupernovaTextFormFieldCopyWithImpl<$Res>
    extends _$SupernovaTextFormFieldCopyWithImpl<$Res,
        _$_PasswordSupernovaTextFormField>
    implements _$$_PasswordSupernovaTextFormFieldCopyWith<$Res> {
  __$$_PasswordSupernovaTextFormFieldCopyWithImpl(
      _$_PasswordSupernovaTextFormField _value,
      $Res Function(_$_PasswordSupernovaTextFormField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? controller = null,
    Object? role = null,
    Object? textInputAction = null,
  }) {
    return _then(_$_PasswordSupernovaTextFormField(
      null == controller
          ? _value.controller
          : controller // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as SupernovaPasswordFormFieldRole,
      textInputAction: null == textInputAction
          ? _value.textInputAction
          : textInputAction // ignore: cast_nullable_to_non_nullable
              as TextInputAction,
    ));
  }
}

/// @nodoc

class _$_PasswordSupernovaTextFormField
    extends _PasswordSupernovaTextFormField {
  const _$_PasswordSupernovaTextFormField(this.controller,
      {required this.role, required this.textInputAction})
      : super._();

  @override
  final TextEditingController controller;
  @override
  final SupernovaPasswordFormFieldRole role;
  @override
  final TextInputAction textInputAction;

  @override
  String toString() {
    return 'SupernovaTextFormField.password(controller: $controller, role: $role, textInputAction: $textInputAction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PasswordSupernovaTextFormField &&
            (identical(other.controller, controller) ||
                other.controller == controller) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.textInputAction, textInputAction) ||
                other.textInputAction == textInputAction));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, controller, role, textInputAction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PasswordSupernovaTextFormFieldCopyWith<_$_PasswordSupernovaTextFormField>
      get copyWith => __$$_PasswordSupernovaTextFormFieldCopyWithImpl<
          _$_PasswordSupernovaTextFormField>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)
        singleLine,
    required TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)
        multiLine,
    required TResult Function(
            TextEditingController controller, TextInputAction textInputAction)
        emailAddress,
    required TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)
        password,
  }) {
    return password(controller, role, textInputAction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult? Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult? Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult? Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
  }) {
    return password?.call(controller, role, textInputAction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            List<TextInputFormatter>? inputFormatters,
            int? maxLength,
            TextCapitalization textCapitalization,
            SupernovaFormFieldValidator<String>? validator,
            TextInputAction textInputAction,
            String? hintText,
            FlatIcon? prefixIcon,
            Widget? suffixIcon)?
        singleLine,
    TResult Function(
            TextEditingController controller,
            List<String>? autofillHints,
            TextInputType? keyboardType,
            int? maxLength,
            SupernovaFormFieldValidator<String>? validator,
            String? hintText)?
        multiLine,
    TResult Function(
            TextEditingController controller, TextInputAction textInputAction)?
        emailAddress,
    TResult Function(
            TextEditingController controller,
            SupernovaPasswordFormFieldRole role,
            TextInputAction textInputAction)?
        password,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password(controller, role, textInputAction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleLineSupernovaTextFormField value)
        singleLine,
    required TResult Function(_MultiLineSupernovaTextFormField value) multiLine,
    required TResult Function(_EmailAddressSupernovaTextFormField value)
        emailAddress,
    required TResult Function(_PasswordSupernovaTextFormField value) password,
  }) {
    return password(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult? Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult? Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult? Function(_PasswordSupernovaTextFormField value)? password,
  }) {
    return password?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleLineSupernovaTextFormField value)? singleLine,
    TResult Function(_MultiLineSupernovaTextFormField value)? multiLine,
    TResult Function(_EmailAddressSupernovaTextFormField value)? emailAddress,
    TResult Function(_PasswordSupernovaTextFormField value)? password,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password(this);
    }
    return orElse();
  }
}

abstract class _PasswordSupernovaTextFormField extends SupernovaTextFormField {
  const factory _PasswordSupernovaTextFormField(
          final TextEditingController controller,
          {required final SupernovaPasswordFormFieldRole role,
          required final TextInputAction textInputAction}) =
      _$_PasswordSupernovaTextFormField;
  const _PasswordSupernovaTextFormField._() : super._();

  @override
  TextEditingController get controller;
  SupernovaPasswordFormFieldRole get role;
  TextInputAction get textInputAction;
  @override
  @JsonKey(ignore: true)
  _$$_PasswordSupernovaTextFormFieldCopyWith<_$_PasswordSupernovaTextFormField>
      get copyWith => throw _privateConstructorUsedError;
}
